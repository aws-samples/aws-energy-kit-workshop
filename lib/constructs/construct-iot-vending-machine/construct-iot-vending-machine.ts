import * as path from 'path';
import { Stack, CfnOutput, CustomResource, Duration, RemovalPolicy } from 'aws-cdk-lib';
import { Construct } from 'constructs';
import * as iot from 'aws-cdk-lib/aws-iot';
import * as iam from 'aws-cdk-lib/aws-iam';
import * as s3 from 'aws-cdk-lib/aws-s3';
import * as codebuild from 'aws-cdk-lib/aws-codebuild';
import * as s3Assets from 'aws-cdk-lib/aws-s3-assets';
import * as cr from 'aws-cdk-lib/custom-resources';
import * as lambda from 'aws-cdk-lib/aws-lambda';
import * as secrets from 'aws-cdk-lib/aws-secretsmanager';
import * as codepipeline from 'aws-cdk-lib/aws-codepipeline';
import * as codepipelineActions from 'aws-cdk-lib/aws-codepipeline-actions';
import { IBucket } from 'aws-cdk-lib/aws-s3';
import { aws_sns as sns} from 'aws-cdk-lib'
import { isNull } from 'lodash';
import { EkS3 } from '../construct-ek-s3-bucket/construct-ek-s3-bucket';

export interface IotVendingMachineProps {
  iotVendingTopic: sns.Topic;
  sitewiseAssetModelId: string;
  greengrassGroupArn: string;
  /**
   * Name of the secret where the password used by the Raspberry Pi to connect to the Wifi is stored
   */
  wifiPasswordSecretName?: string;
  /**
   * Country code for the Wifi network (e.g. 'US')
   */
  wifiCountry?: string;
  /**
   * SSID of the Wifi network the Raspberry Pi will connect to
   */
  wifiSsid?: string;

  imageType: string;
}

//TODO --> use this to update below https://docs.aws.amazon.com/greengrass/v2/developerguide/fleet-provisioning-setup.html

export class IotVendingMachine extends Construct {
  /**
   * Name of the archive containing the configured Raspberry pi image builder
   */
  private readonly rpiImageBuilderArchiveName: string = 'rpi-image-builder.zip';
  /**
   * Name of the archive containing the custom Raspberry pi image
   */
  private readonly customImageArchiveName: string;
  public readonly provisionByClaimSourceBucket: IBucket

  /**
   * Create a CodePipeline that builds a custom raspios image.
   * This custom raspios image automatically provisions a RaspberryPi with AWS IoT on its first boot.
   * @param scope 
   * @param id 
   * @param props 
   */
  constructor(scope: Construct, id: string, props: IotVendingMachineProps) {
    super(scope, id);

    // Policy attached to IoT things generated by this stack
    const thingsPolicy = new iot.CfnPolicy(this, 'thingsPolicy', {
      policyDocument: {
        'Version': '2012-10-17',
        'Statement': [
          {
            "Effect": "Allow",
            "Action": [
              "iot:Connect",
              "iot:Publish",
              "iot:Subscribe",
              "iot:Receive",
              "iot:Connect",
              "greengrass:*",
            ],
            "Resource": [
              // TODO determine if this needs to be * or if it can be this specific
              `arn:aws:iot:${Stack.of(this).region}:${Stack.of(this).account}:client/\${iot:Connection.Thing.ThingName}`,
            ]
            //TODO consider removing the rest of this policy --> figure out what MQTT topics need to be included and how
          },
          {
              "Effect": "Allow",
              "Action": [
                  "iot:Subscribe",
              ],
              "Resource": [
                `arn:aws:iot:${Stack.of(this).region}:${Stack.of(this).account}:topicfilter/\${iot:Connection.Thing.ThingName}/*`,
                `arn:aws:iot:${Stack.of(this).region}:${Stack.of(this).account}:topicfilter/openworld`,
              ]
          },
          {
              "Effect": "Allow",
              "Action": [
                  "iot:Publish",
                  "iot:Receive",
              ],
              "Resource": [
                  `arn:aws:iot:${Stack.of(this).region}:${Stack.of(this).account}:topic/\${iot:Connection.Thing.ThingName}/*`,
                  `arn:aws:iot:${Stack.of(this).region}:${Stack.of(this).account}:topic/openworld`,
              ]
          },
          {
            "Effect": "Allow",
            "Action": [
              "greengrass:Discover"
            ],
            "Resource": [
              "*"
            ]
          }
        ]
      }
    });

    // Give the AWS IoT service permission to create or update IoT resources such as things and certificates in your account when provisioning devices
    const thingProvisioningRole = new iam.Role(this, 'ThingProvisioningRoleArn', {
      assumedBy: new iam.ServicePrincipal('iot.amazonaws.com'),
    });
    thingProvisioningRole.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName('service-role/AWSIoTThingsRegistration'));
    

    // The bucket where the configured rpi-image-builder used as a source of the pipeline is stored
    const rpiImageBuilderSourceBucket = new EkS3(this, 'rpiImageBuilderSourceBucket', {
      versioned: true,
    });

    this.provisionByClaimSourceBucket = rpiImageBuilderSourceBucket;

    // The bucket where the custom raspios image created by the pipeline is stored
    const rpiImageOutputBucket = new EkS3(this, 'RpiImageOutputBucket', {
      versioned: true,
    });

    // Lambda that configures the rpi-image-builder and stores it in the pipeline source bucket
    const configureRpiImageBuilderFunction = new lambda.Function(this, 'ConfigureRpiImageBuilderFunction', {
      runtime: lambda.Runtime.PYTHON_3_12,
      handler: 'app.on_event',
      code: lambda.Code.fromAsset(path.join(__dirname, './lambda/configure_rpi_image_builder')),
      timeout: Duration.seconds(60),
      initialPolicy: [
        new iam.PolicyStatement({
          effect: iam.Effect.ALLOW,
          actions: [
            'iot:CreateKeysAndCertificate',
            'iot:AttachPolicy',
            'iot:DescribeEndpoint',
          ],
          resources: ['*'],
        }),
      ],
    });

    // Lambda that configures the rpi-image-builder and stores it in the pipeline source bucket
    const postProvisionHooksFunction = new lambda.Function(this, 'PostProvisionHooksFunction', {
      runtime: lambda.Runtime.PYTHON_3_12,
      handler: 'app.on_event',
      code: lambda.Code.fromAsset(path.join(__dirname, './lambda/post_provision_hooks')),
      timeout: Duration.seconds(900),
      environment: {
        "SNS_TOPIC": props.iotVendingTopic.topicArn,
        "SITEWISE_ASSET_MODEL_ID": props.sitewiseAssetModelId,
        "GGCD_GROUP_ARN": props.greengrassGroupArn
      },
      initialPolicy: [
        new iam.PolicyStatement({
          effect: iam.Effect.ALLOW,
          actions: [
            'sns:Publish',
            'iotsitewise:*',
            'iotsitewise:CreateAsset',
            'iotsitewise:TagResource',
            'greengrass:BatchAssociateClientDeviceWithCoreDevice',
            'greengrass:ListCoreDevices'
          ],
          resources: ['*'],
        }),
      ],
    });

    // Lambda that configures the rpi-image-builder and stores it in the pipeline source bucket
    const preProvisionHooksFunction = new lambda.Function(this, 'PreProvisionHooksFunction', {
      runtime: lambda.Runtime.PYTHON_3_12,
      handler: 'app.on_event',
      code: lambda.Code.fromAsset(path.join(__dirname, './lambda/pre_provision_hooks')),
      timeout: Duration.seconds(60),
      environment: {
        "SNS_TOPIC": props.iotVendingTopic.topicArn,
        "POST_PROVISION_HOOK_LAMBDA_NAME": postProvisionHooksFunction.functionName
      },
      initialPolicy: [
        new iam.PolicyStatement({
          effect: iam.Effect.ALLOW,
          actions: [
            'sns:Publish',
            'iotsitewise:*',
            'iotsitewise:CreateAsset',
            'iotsitewise:TagResource',
            'greengrass:BatchAssociateClientDeviceWithCoreDevice',
            'greengrass:ListCoreDevices'
          ],
          resources: ['*'],
        }),
      ],
    });

    const iotPrincipal = new iam.ServicePrincipal('iot.amazonaws.com');

    preProvisionHooksFunction.grantInvoke(iotPrincipal);

    postProvisionHooksFunction.grantInvoke(preProvisionHooksFunction)

    postProvisionHooksFunction.grantInvoke(iotPrincipal);
    
    const postProvisionPolicy = new iam.PolicyStatement({
      actions: ['lambda:InvokeFunction'],
      resources: [postProvisionHooksFunction.functionArn],
    });

    const preProvisionPolicy = new iam.PolicyStatement({
      actions: ['lambda:InvokeFunction'],
      resources: [preProvisionHooksFunction.functionArn],
    });

    iotPrincipal.addToPrincipalPolicy(preProvisionPolicy)

    iotPrincipal.addToPrincipalPolicy(postProvisionPolicy)

    /**
          * Add lambda invoke for pre-provision policy to the iot service principal.
          * This allows iot service to invoke the lambda function.
          * TODO - verify that this solves the preprovision hooks issue
         */
    iotPrincipal.addToPrincipalPolicy(preProvisionPolicy)

    const snsTopicPolicy = new iam.PolicyStatement({
      actions: ['sns:publish'],
      resources: ['*'],
    });

    preProvisionHooksFunction.addToRolePolicy(snsTopicPolicy);

    postProvisionHooksFunction.addToRolePolicy(snsTopicPolicy);

    // The provisioning template used to create Embedded Device IoT Things
    // This template takes the IoT hostname+device serial number and uses them as the thingname
    // It also uses a pre-provisioning hook to fire a lambda function on provision
    // https://docs.aws.amazon.com/iot/latest/developerguide/provision-template.html
    const thingProvisioningTemplate = new iot.CfnProvisioningTemplate(this, 'ThingProvisioningTemplate', {
      provisioningRoleArn: thingProvisioningRole.roleArn,
      enabled: true,
      preProvisioningHook: {
        payloadVersion: '2020-04-01',
        targetArn: preProvisionHooksFunction.functionArn,
      },
      templateBody: `{
        "Parameters": {
          "SerialNumber": {
            "Type": "String"
          },
          "AWS::IoT::Certificate::Id": {
            "Type": "String"
          }
        },
        "Resources": {
          "certificate": {
            "Properties": {
              "CertificateId": {
                "Ref": "AWS::IoT::Certificate::Id"
              },
              "Status": "Active"
            },
            "Type": "AWS::IoT::Certificate"
          },
          "policy": {
            "Properties": {
              "PolicyName": "${thingsPolicy.ref}"
            },
            "Type": "AWS::IoT::Policy"
          },
          "thing": {
            "OverrideSettings": {
              "AttributePayload": "MERGE",
              "ThingGroups": "DO_NOTHING",
              "ThingTypeName": "REPLACE"
            },
            "Properties": {
              "ThingGroups": [],
              "ThingName": {
                "Ref": "SerialNumber"
              }
            },
            "Type": "AWS::IoT::Thing"
          }
        },
        "DeviceConfiguration": {
        }
      }`
    });

    // AWS IoT fleet provisioning uses claim certificates to generate things certificates
    // This policy restricts the use of claim certificates to device provisioning
    const thingFleetProvisioningPolicy = new iot.CfnPolicy(this, 'ThingFleetProvisioningPolicy', {
      policyDocument: {
        "Version": "2012-10-17",
        "Statement": [
          {
            "Effect": "Allow",
            "Action": ["iot:Connect"],
            "Resource": ["*"]
          },
          {
            "Effect": "Allow",
            "Action": ["iot:Publish", "iot:Receive"],
            "Resource": [
              `arn:aws:iot:${Stack.of(this).region}:${Stack.of(this).account}:topic/$aws/certificates/create/*`,
              `arn:aws:iot:${Stack.of(this).region}:${Stack.of(this).account}:topic/$aws/provisioning-templates/${thingProvisioningTemplate.ref}/provision/*`
            ]
          },
          {
            "Effect": "Allow",
            "Action": ["iot:Subscribe"],
            "Resource": [
              `arn:aws:iot:${Stack.of(this).region}:${Stack.of(this).account}:topicfilter/$aws/certificates/create/*`,
              `arn:aws:iot:${Stack.of(this).region}:${Stack.of(this).account}:topicfilter/$aws/provisioning-templates/${thingProvisioningTemplate.ref}/provision/*`
            ]
          }
        ]
      }
    });

    // Store the rpi-image-builder source code in S3
    const rpiImageBuilderAsset = new s3Assets.Asset(this, 'RpiImageBuilderAsset', {
      path: path.join(__dirname, `./rpi-image-builder-thing`),
    });

    rpiImageBuilderSourceBucket.grantWrite(configureRpiImageBuilderFunction);
    rpiImageBuilderAsset.grantRead(configureRpiImageBuilderFunction);

    // Custom resource that calls the Lambda that will configure the rpi-image-builder client
    new CustomResource(this, 'ConfigureRpiImageBuilderCR', {
      serviceToken: new cr.Provider(this, 'ConfigureRpiImageBuilderProvider', {
        onEventHandler: configureRpiImageBuilderFunction,
      }).serviceToken,
      properties: {
        'FLEET_PROVISIONING_POLICY_NAME': thingFleetProvisioningPolicy.ref,
        'PROVISIONING_TEMPLATE_NAME': thingProvisioningTemplate.ref,
        'RPI_IMAGE_BUILDER_BUCKET_NAME': rpiImageBuilderAsset.s3BucketName,
        'RPI_IMAGE_BUILDER_OBJECT_KEY': rpiImageBuilderAsset.s3ObjectKey,
        'CONFIGURED_RPI_IMAGE_BUILDER_BUCKET_NAME': rpiImageBuilderSourceBucket.bucketName,
        'CONFIGURED_RPI_IMAGE_BUILDER_OBJECT_KEY': this.rpiImageBuilderArchiveName
      },
    });

    console.log(`Image type is ${props.imageType}`)
    if (props.imageType != "simulator") {
    console.log(`Building Rpi Image!`)
    // Codebuild project that generates the custom raspios image
    const buildRpiImageProject = new codebuild.PipelineProject(this, 'BuildRpiImageProject', {
      environment: {
        /**
         * Use ARM image (on Graviton)
         * This reduces overall compute energy usage for sustainability.
         * It also allows us to build within ARM architecture so that we can
         * chroot and build a custom RPi image.
         */
        buildImage: codebuild.LinuxArmBuildImage.AMAZON_LINUX_2_STANDARD_2_0,
        privileged: true,
      },
      buildSpec: codebuild.BuildSpec.fromObject({
        version: '0.2',
        env: {
          variables: {
            // Set environment variables expected by the build-rpi-image.bash script
            'WIFI_SSID': props.wifiSsid,
            'WIFI_COUNTRY': props.wifiCountry,
            'ARTIFACT_IMAGE_NAME': `energykit-${props.imageType}-raspios.img`,
            'AWS_REGION': Stack.of(this).region
          },
          'secrets-manager': {
            'WIFI_PASSWORD': `${props.wifiPasswordSecretName}`,
          },
        },
        phases: {
          install: {
            commands: [
              // Install dependencies required by the build-rpi-image.bash script
              "yum install -y kpartx",
              "yum install -y git"
            ],
          },
          build: {
            commands: [
              'bash build-rpi-image.bash'
            ],
          },
        },
        artifacts: {
          files: [
            '$ARTIFACT_IMAGE_NAME',
          ],
        },
      }),
    });

    // Give access to the secret containing the wifi password to the codebuild project
    const wifiPasswordSecretName = props?.wifiPasswordSecretName

    if (wifiPasswordSecretName) {
    if (buildRpiImageProject.role) {
      const rpiSecret = secrets.Secret.fromSecretNameV2(this, 'RPIVendingSecrets', wifiPasswordSecretName);
      rpiSecret.grantRead(buildRpiImageProject.role);
    }
  }

    const pipelineSourceArtifact = new codepipeline.Artifact();
    const buildOutputArtifact = new codepipeline.Artifact();

    new codepipeline.Pipeline(this, 'BuildRpiImagePipeline', {
      crossAccountKeys: false,
      restartExecutionOnUpdate: true,
      stages: [
        {
          stageName: 'Source',
          actions: [
            new codepipelineActions.S3SourceAction({
              actionName: 'Source',
              bucket: rpiImageBuilderSourceBucket,
              bucketKey: this.rpiImageBuilderArchiveName,
              output: pipelineSourceArtifact,
            }),
          ],
        },
        {
          stageName: 'BuildRpiImage',
          actions: [
            new codepipelineActions.CodeBuildAction({
              actionName: 'BuildRpiImage',
              input: pipelineSourceArtifact,
              project: buildRpiImageProject,
              outputs: [buildOutputArtifact],
            }),
          ],
        },
        {
          stageName: 'StoreRpiImage',
          actions: [
            new codepipelineActions.S3DeployAction({
              actionName: 'StoreRpiImage',
              input: buildOutputArtifact,
              bucket: rpiImageOutputBucket,
              extract: false,
              objectKey: `energykit-${props.imageType}-raspios.img`,
            }),
          ],
        },
      ],
    });

    new CfnOutput(this, 'RpiImageBucketName', {
      description: `Download the EnergyKit raspios image for ${Stack.of(this).stackName} from this S3 bucket`,
      value: rpiImageOutputBucket.bucketWebsiteUrl,
      exportName: `${props.imageType}-s3-bucket`
    });
  }

  }
}

